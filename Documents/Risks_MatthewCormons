// CSCI MC RISKS

1) Printing a non-User Piece square on the Game board

One of the biggest risks that I had to overcome in this project was printing a non-user Piece game board.
One of the bigger challenges relating to this issue was actually printing to the board in the first place 
without substantially changing the game board itself.  To solve this problem, I found that all I had to do 
was set isEmpty to false.  Once this had been done, a square with the default color, pink appeared.  
Furthermore, this square reported a collision with the isBoardBlock collision method when a piece ran
into said square.  Thus, with the addition of a method in the VBTetrisPowerUp class, I was easily able to 
detect when a piece collided with a power up.  Removing this piece from the board was just as simple; all
I had to do was set the isEmpty of the block containing the power up back to true.  Unfortunately, the implementation
did not end here; during game play testing I noticed that random lines of blocks of the default pink color would 
appear stretching from the bottom of the game play area to the top.  Furthermore, these lines were persistent 
and would not go away.  In attempting to solve this problem I was able to deduce that these lines were being generated by    
power ups being put on the game board.  To solve this problem, I simply emptied the game board of all blocks that 
had the default ownership of 0 whenever I attempted to add a new power up to the board.  Thus, I solved this problem 
and overcame this risk.

2) Getting multiple actions to occur for a single power up.

When I was implementing several of the power ups I found that said power ups required multiple stages
to complete.  However, I needed to implement several power ups with the possibility of including even more
in the future.  Thus, any solutions I came up with would have to be able to handle any type and number of power 
ups. For this reason, I determined it would be easiest to create an abstract base class for all of my power ups.
Furthermore, I was able to determine that any power up I wanted to encode could be completed in 2 stages.  Thus,
for each of these stages I created an abstract method in the power up base class I was creating.  From there, I 
simply had to override the two abstract methods for every power up I wanted to include in the program.  Thus, I 
was able to carry out multiple part actions for a single power up.

3) Timing for time based power ups

For some of the power ups I was implementing I noticed that a timer would be very suitable.  Thus, I had to find 
a way in order to make timers work.  Thus, I had to find a way for a body of code to be executed after a certain 
period of time.  I started off by trying to take the current time for some base period and then afterwards 
repetitively getting the current time and taking the difference of this current time with the base time period with
the goal of stopping and executing the body of code aforementioned when the difference got to be a certain size.  
Unfortunately, this did not work at all.  Thus, in order to overcome this risk, I decided to use the java.util.Timer 
library.  From this, I was able to implement a subclass extending TimerTask in each class that required a timer to
be used.  In each of these subclasses, in the run method I implemented a method to carry out the necessary
tasks for completing the use of the given power up as well as timer.cancel() in order to get rid of the timer.  
Then, in the body of the first action to be caused by a power up I simply created a new timer that was set to
execute the timer task run method after a certain period of time.  Thus, I was able to take care of this risk.

4) Getting the FireFly piece to rotate in the way it does without causing an array out of bounds error

I first conceived of the FireFly piece after I made a mistake trying to make a singleton piece.  I noticed that the
piece rotated in a fashion that was not normal for such a piece.  Thus, I decided to keep track of this mistake
and use it as a power up.  I first tried to implement the power up exactly as the mistake had appeared to me.  This
consisted of making every block in the piece I was trying to make have a coordinate pair of {1, 1}.
Unfortunately, as indicated by the title of this risk, when I tried to rotate the piece within approximately 4 rows 
of the bottom of the game board I would receive an array out-of-bounds crash during the middle of the game.  
It appeared as though the tryMove method in game board, the method designed to prevent invalid moves, did not work.  I
then tried further ways of arranging the coordinates of the blocks making a singleton piece in order to achieve the
same results as I had seen before with no success.  Thus, since what I was trying to create was a piece, I decided 
to create a subclass of VBTetrisPiece in which I overloaded the rotate method and created a new method called
setsShape.  The method setsShape did exactly what the method setShape did in the parent class except for it is
only able to create a singleton block shape.  The overloaded rotate method was as follows: for some counter
initialized to 0 and incremented every time a rotate occurs if counter%4 == 0 move the piece 1 space right,
if counter%4 == 1 move the piece 1 space up, if counter%4 == 2 move the piece 1 space left, and if
counter%4 == 3 move the piece 1 space down.  This implementation, since it closely mimics common game play 
situations, allowed tryMove to work as designed.  Thus, FireFly was able to work as expected with out causing an
out of bounds error related crash.   